## Presenter是否应该包含Actiivty或者Fragment的生命周期？  

&emsp;&emsp;MVP是一种比较简单比较轻松的模式，但是自身内部并没有什么严格的划分标准，广义上来讲只要满足Model/View的解耦基本特征，都算是一个MVP模式。就是因为这样，每个人的理解都不尽相同，写法也千差万别。  
&emsp;&emsp;在实践中总是会有各种疑问，觉得不应该这样写，但是转念一想，这样写是站得住脚的。比如这个问题---**Presenter是否应该承载Activity或者Fragment生命周期？**   
&emsp;&emsp;在MVP中的众多写法中，有一个很极端的写法，甚至说吹毛求疵也不为过。在这种写法的思想中，强调View层的完全抽离。View包含哪些东西？在我们一般的意识中，View层直观上指的就是Activity和Fragment以及其他的UI展示组件，不仅包含展示的UI，还有他们的生命周期。那么问题就在这，生命周期以及依赖生命周期的逻辑(业务orUI)算是View层吗？在这种“强迫症式”的写法中，生命周期被自然而然的归类到业务逻辑那一层，也就是Model，或者Presenter以及其他什么东西。反正UI就是UI，生命周期不仅和UI有关，和业务逻辑也有关系。所以在这种MVP模式的写法里，我们的代码基础不再是Activity或者Fragment，而是一个个独立的View，更加轻量级更加纯粹的View。   
&emsp;&emsp;不管是不是上述的那种MVP模式，但有一点我们是无论如何也逃避不了的---Presenter有时候的确需要和生命周期发生关系，生命周期至少在某个角度上来说是属于业务层的东西。那么Presenter应该包含生命周期吗？   
&emsp;&emsp;在解耦的角度来讲，我们希望Presenter更加独立，最好依赖于抽象的业务模块而不是某个界面，这样可以在其他需要同样业务模块的地方，低代价高效率的重用Presenter，引入->创建->调用，完事儿。如果这个Presneter中的某些逻辑需要生命周期，但是本身又不具备生命周期的感知能力，那么会有大量的逻辑暴露在某个特定的界面中，那么这个Presenter就称不上依赖于业务模块的Presenter而是依赖于界面的Presenter，势必在之后的重用中造成很多不便，甚至根本不能重用。MVP的精髓是什么？解耦，解耦的精髓是什么？重用性。这样Presenter实际上只做到了View与Model的某种解耦，而很难说是个真正的MVP，至少我是这么认为的。基于这个层面的考虑，Presenter确实应该包含生命周期，至少是生命周期敏感的。现在我们有多方法做到这一点，Jetpack的LifeCycle，原生好用，看似简单实则强大；LightCycle，使用方便封装良好；最不济，我们自己写一个工具也没有多难。问题是，View变得更轻了，Presenter反而更加复杂，这对解耦和重用可不是一个好现象。  
&emsp;&emsp;生命周期复杂吗？复杂，如果再加上必要的业务逻辑和UI逻辑，复杂程度会直线上升，那么问题来了，既然生命周期已经很复杂了，我们还有必要把它引入到Presenter中吗？过分的强调View层，就会让Presneter变得更复杂，而复杂性越高越不利于解耦和重用。Model负责主要的业务逻辑，View用来处理UI展示，Presenter居中调度，分离两者。每个层面都有自己的事情要做，就算是基于单一职责原则，我们也不应该把生命周期放到Presenter中。Model的业务原则上是生命周期不敏感的，否则破坏的是Model本身的内聚程度和重用性。所以到这里我竟然产生了一个很不正常的想法---让Model的具体业务直接依赖View的生命周期，然后在把Model作为构造参数直接传回Presenter。如果这样的话，Presneter保持了自己的单一职责，Model也感知了生命周期(但是Model可能会变的很“模糊”)，两全其美，并且重用起来，好像也不会有太大的问题。那么不正常的地方在哪？MVP模式在于View和Model的分离，如果这样做，实际上是在像MVC靠拢，MVP也就变成了一个强化版的MVC。    
&emsp;&emsp;那么，Presenter到底应不应该包含生命周期呢？而MVP的本质到底是什么？
